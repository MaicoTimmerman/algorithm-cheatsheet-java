\section{Autres}
\begin{center}
	\includegraphics[width=0.7\linewidth]{whyuno.jpg}
\end{center}
\subsection{Permutations, Combinaisons, Arrangements... {\footnotesize \textit{non-testé}}}
\begin{lstlisting}
void nextPerm(int[] p) {
  int n = p.length;
  int k = n - 2;
  while(k >= 0 && p[k] >= p[k + 1]) {k--;}
  int l = n - 1;
  while(p[k] >= p[l]) {l--;}
  swap(p, k, l);
  reverse(p, k + 1, n);
}

LinkedList<Integer> getIPermutation(int n, int index) {
  LeftRightArray lr = new LeftRightArray(n);
  lr.freeAll();
  LinkedList<Integer> perm = new 
  LinkedList<Integer>();
  getPermutation(lr, index, fact(n), perm);
  return perm;
}

void getPermutation(LeftRightArray lr, int i, long fact, LinkedList<Integer> perm) {
  int n = lr.size();
  if(n == 1) {
    perm.add(lr.freeIndex(0, false));
  } else {
    fact /= n;
    int j = (int)(i / fact);
    perm.add(lr.freeIndex(j, true));
    i -= j * fact;
    getPermutation(lr, i, fact, perm);
  }
}

int[] getICombinadic(int n, int k, long i) { 
  int[] comb = new int[k];
  int j = 0;
  for(int z = 1; z <= n; z++) {
    if ( k == 0 ) {
      break;
    }
    long threshold = C(n - z, k - 1);
    if (i < threshold) {
      comb[j] = z - 1;
      j++;
      k = k - 1;
    } else if (i >= threshold) {
      i = i - threshold;
    }
  }
  return comb;
}

void combinations(int n, int k) {
  combinations(n, 0, new int[k], 0);
}

void combinations(int n, int j, int[] comb, int k) {
  if(k == comb.length) {
    System.out.println(Arrays.toString(comb));
  } else {
    for(int i = j; i < n; i++) {
      comb[k] = i;
      combinations(n, i + 1, comb, k + 1);
    }
  }
}
void subsets(int[] set) {
  int n = (1 << set.length);
  for(int i = 0; i < n; i++) {
    int[] sub = new int[Integer.bitCount(i)];
    int k = 0, j = 0;
    while((1 << j) <= i) {
      if((i & (1 << j)) == (1 << j)) {
        sub[k++] = set[j];
      }
      j++;  
    }
    System.out.println(Arrays.toString(sub));
  }
}
\end{lstlisting}
\subsection{Décomposition en fractions unitaires {\footnotesize \textit{non-testé}}}
Ecrire $0<\frac{p}{q}<1$ sous forme de sommes de $\frac{1}{k}$
\begin{lstlisting}
void expandUnitFrac(long p, long q)
{
	if(p != 0)
	{
		long i = q % p == 0 ? q/p : q/p + 1;
		System.out.println("1/" + i);
		expandUnitFrac(p*i-q, q*i);
	}
}
\end{lstlisting}
\subsection{Combinaison}
Nombre de combinaison de taille $k$ parmi $n$ ($C^k_n$)

Cas spécial: $C^k_n\ mod\ 2 = n\oplus m$
\begin{lstlisting}
long C(int n, int k)
{
	double r = 1;
	k = Math.min(k, n - k);
	for(int i = 1; i <= k; i++)
		r /= i;
	for(int i = n; i >= n - k + 1; i--)
		r *= i;
	return Math.round(r);
}
\end{lstlisting}
%TODO: Nombres de Catalan
\subsection{Suite de fibonacci {\footnotesize \textit{non-testé}}}
$f(0) = 0$, $f(1) = 1$ et $f(n) = f(n - 1) + f(n - 2)$.\\
On a la relation suivante, qui permet de calculer tout nombre de la suite en $O(log(n))$:\\
$$\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}^n=\begin{pmatrix}
f_{n+1} & f_n\\
f_n & f_{n-1}
\end{pmatrix}$$
\begin{lstlisting}
long fib(n)
{
	int i=1; int h=1; int j=0; int k=0; int t;
	while(n > 0)
	{
		if(n % 2 == 1)
		{
			t = j * h;
			j=i * h + j * k + t; 
			i=i * k + t;
    		}
   		t = h * h;
   		h = 2 * k * h + t;
   		k = k * k + t;
	}
	n = (int)n / 2; 
	return j;
}
\end{lstlisting}

\subsection{Strings {\footnotesize \textit{non-testé et non-relu}}}
\begin{lstlisting}

\end{lstlisting}
\subsubsection{Palindrome maximum}
\begin{lstlisting}
int[] calculateAtCenters(String s) {
  int n = s.length();
  int[] L = new int[2 * n + 1];
  int i = 0, palLen = 0, k = 0;
  while(i < n) {
    if((i > palLen) && 
       (s.charAt(i - palLen - 1)==s.charAt(i))) {
      palLen += 2;
      i += 1;
      continue;
    }
    L[k++] = palLen;
    int e = k - 2 - palLen;
    boolean found = false;
    for(int j = k - 2; j > e; j--) {
      if(L[j] == j - e - 1) {
        palLen = j - e - 1;
        found = true;
        break;
      }
      L[k++] = Math.min(j - e - 1, L[j]);
    }
    if(!found) {
      i += 1;
      palLen = 1;
    }
  }
  L[k++] = palLen;
  int e = 2 * (k - n) - 3;
  for(i = k - 2; i > e; i--) {
    int d = i - e - 1;
    L[k++] = Math.min(d, L[i]);
  }
  return L;
}

String getPalindrome(String s, int[] L) {
  int max = L[0];
  int maxI = 0;
  for(int i = 1; i < L.length; i++) {
    if(L[i] > max) {
      max = L[i];
      maxI = i;
    }
  }
  int b = 0, e = 0;
  b = maxI / 2 - L[maxI] / 2;
  e = maxI / 2 + L[maxI] / 2;
  e += maxI % 2 == 0 ? 0 : 1;
  return s.substring(b, e);
}

String getPalindrome(String s)
{
	return getPalindrome(s, calculateAtCenters(s));
}
\end{lstlisting}
\subsection{La réponse}
\begin{lstlisting}
int reponse() { return 42; }
\end{lstlisting}
\subsection{Occurences dans une chaine}
KMP(s,w) renvoie la position des occurences de w dans s.
\begin{lstlisting}
LinkedList<Integer> KMP(String s, String w) {
  LinkedList<Integer> matches = new  
  LinkedList<Integer>();
  int k = 0, i = -1;
  int[] t = KMPtable(w);
  do {
    i = KMP(s, w, k, t);
    if(i != -1) {
      matches.add(i);
      // change to i+len(w) disalow overlap
      k = i + 1; 
    }
  } while(i != -1 && k < s.length());
  return matches;
}
	
int KMP(String s, String w, int k, int[] t) {
  int i = 0;
  int n = s.length(), m = w.length();
  while(k + i < n) {
    if(w.charAt(i) == s.charAt(k + i)) {
      i++;
      if(i == m) {return k;}
    } else {
      k += i - t[i];
      i = t[i] > -1 ? t[i] : 0;
    }
  }
  return -1;
}

int[] KMPtable(String w) {
  int m = w.length();
  int[] t = new int[m];
  int pos = 2, cnd = 0;
  t[0] = -1;
  t[1] = 0;
  while(pos < m) {
    if(w.charAt(pos - 1) == w.charAt(cnd)) {
      t[pos++] = ++cnd;
    } else if(cnd > 0) {
      cnd = t[cnd];
    } else {
      t[pos++] = 0;
    }
  }
  return t;
}
\end{lstlisting}
\subsection{Algorithmes de tri {\footnotesize \textit{non-testé}}}
\begin{lstlisting}
int findKth(int[] A, int k, int n) {
  if(n <= 10) {
    Arrays.sort(A, 0, n);
    return A[k];
  }
  int nG = (int)Math.ceil(n / 5.0);
  int[][] group = new int[nG][];
  int[] kth = new int[nG];
  for(int i = 0; i < nG; i++) {
    if(i == nG - 1 && n % 5 != 0) {
      group[i] = Arrays.copyOfRange(A, (n/5)* 5, n);
      kth[i] = findKth(group[i], group[i].length / 2, 
                     group[i].length);
    } else {
      group[i] = Arrays.copyOfRange(A, i*5, (i+1)*5);
      kth[i] = findKth(group[i], 2, group[i].length);
    }
  }
  int M = findKth(kth, nG / 2, nG);
  int[] S = new int[n]; 
  int[] E = new int[n];
  int[] B = new int[n];
  int s = 0, e = 0, b = 0;
  for(int i = 0; i < n; i++) {
    if(A[i] < M) {
      S[s++] = A[i];
    } else if(A[i] > M) {
      B[b++] = A[i];
    } else {E[e++] = A[i];}
  }
  if(k < s) {
    return findKth(S, k, s);
  } else if(k >= s + e) {
    return findKth(B, k - s - e, b);
  }
  return M;
}

int[] countSort(int[] A, int k) { // O(n + k)
  int[] C = new int[k];
  for(int j = 0; j < A.length; j++) {
    C[A[j]]++;
  }
  for(int j = 1; j < k; j++) {
    C[j] += C[j - 1];
  }
  int[] B = new int[A.length];
  for(int j = A.length - 1; j >= 0; j--) {
    B[C[A[j]] - 1] = A[j];
    C[A[j]]--;
  }
  return B;
}
	
int[][] radixSort(int[][] nums, int k) { // O(d*(n+k))
  int n = nums.length;
  int m = nums[0].length;
  int[][] B = null;
  for(int i = m - 1; i >= 0; i--) {
    int[] C = new int[k];
    for(int j = 0; j < n; j++) {
      C[nums[j][i]]++;
    }
    for(int j = 1; j < k; j++) {
      C[j] += C[j - 1];
    }
    B = new int[n][];
    for(int j = n - 1; j >= 0; j--) {
      B[C[nums[j][i]] - 1] = nums[j];
      C[nums[j][i]] = C[nums[j][i]] - 1;
    }
    nums = B;
  }
  return nums;
}

int mergeSort(int[] a) { 
  int n = a.length;
  if(n == 1) {return 0;}
  int m = n / 2;
  int[] left = Arrays.copyOfRange(a, 0, m);
  int[] right = Arrays.copyOfRange(a, m, n);
  int inv = mergeSort(left);
  inv += mergeSort(right);
  inv += merge(left, right, a);
  return inv;
}

int merge(int[] left, int[] right, int[] a) {
  int i = 0, l = 0, r = 0, inv = 0;
  while(l < left.length && r < right.length) {
    if(left[l] <= right[r]) {
      a[i++] = left[l++];
    } else {
      inv += left.length - l;
      a[i++] = right[r++];
    }
  }
  for(int j = l; j < left.length; j++) {
    a[i++] = left[j];
  }
  for(int j = r; j < right.length; j++) {
    a[i++] = right[j];
  }
  return inv;
}

int countMinSwapsToSort(int[] a) {
  int[] b = a.clone();
  Arrays.sort(b);
  int nSwaps = 0;
  for(int i = 0; i < a.length; i++) {
    // cuidado com elementos repetidos!
    int j = Arrays.binarySearch(b, a[i]);
    if(b[i] == a[j] && i != j) {
      nSwaps++;
      swap(a, i, j);
    }
  }
  for(int i = 0; i < a.length; i++) {
    if(a[i] != b[i]) {
      nSwaps++;
    }
  }
  return nSwaps;
}

//Count (i, j):h[i] <= h[k] <= h[j], k = i+1,...,j-1.
int countVisiblePairs(int[] h) { // O(n) 
  int n = h.length;
  int[] p = new int[n];
  int[] r = new int[n];
  Stack<Integer> S = new Stack<Integer>();
  for(int i = 0; i < n; i++) {
    int c = 0;
    if(S.isEmpty()) {
      S.push(h[i]);
      p[i] = 0;
    } else {
      if(S.peek() == h[i]) {
        p[i] = p[i - 1] + 1 - r[i - 1];
      } else {
        while(!S.isEmpty() && S.peek() < h[i]) {
	   S.pop();
	   c++;
	 }
	 p[i] = c;
	 r[i] = c;
	 if(!S.isEmpty()) {
	   p[i]++;
	 }
      }
    S.push(h[i]);
    }
  }
  return sum(p);
}

void shuffle(Object[] a)
{
  int N = a.length;
  for (int i = 0; i < N; i++) {
    int r = i + (int) (Math.random() * (N-i));
    swap(a, i, r);
  }
}
\end{lstlisting}
\subsection{Huffman (compression)}
Normalement utilisé pour des caractères, mais utilisables avec tout ce dont on peux compter les occurences.\\
Construit un arbre (de préfixe) qu'on utilise pour décoder et qu'on dépile pour encoder.
\begin{lstlisting}
class HuffmanNode implements Comparable<HuffmanNode>
{
  public boolean isLeaf;
  public int occurences;
  public int charIndex;
  public HuffmanNode left,right;
  public HuffmanNode(HuffmanNode left, HuffmanNode right)
  {
    this.occurences = left.occurences+right.occurences;
    this.left = left;
    this.right = right;
    isLeaf = false;
  } 
  public HuffmanNode(int charIndex, int occurences)
  {
    this.charIndex = charIndex;
    this.occurences = occurences;
    isLeaf = true;
  }
  @Override
  public int compareTo(HuffmanNode o) {
    return occurences-o.occurences;
  }
}
HuffmanNode getHuffmanTree(int[] occurences) {
  PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>();
  for(int i = 0; i < occurences.length; i++)
    q.add(new HuffmanNode(i, occurences[i]));
  while(q.size() != 1) {
    HuffmanNode right = q.poll();
    HuffmanNode left = q.poll();
    q.add(new HuffmanNode(left, right));
  }
  return q.poll();
}
void getHuffmanTable(HuffmanNode tree, BitSet[] result, BitSet current, int pos){
  if(tree.isLeaf) {
    BitSet finalBitSet = new BitSet();
    for(int i = 0; i < pos; i++)
      finalBitSet.set(i, current.get(pos-i-1));
    result[tree.charIndex] = finalBitSet;
  } else {
    BitSet leftBitSet = new BitSet();
    leftBitSet.or(current);
    leftBitSet.set(pos, false);
    getHuffmanTable(tree.left, result, leftBitSet, pos+1);
            
    BitSet rightBitSet = new BitSet();
    rightBitSet.or(current);
    rightBitSet.set(pos, true);
    getHuffmanTable(tree.right, result, rightBitSet, pos+1);
  }
}
    
//n=occurences.length
static BitSet[] getHuffmanTable(int n, HuffmanNode tree) {
  BitSet[] result = new BitSet[n];
  getHuffmanTable(tree, result, new BitSet(), 0);
  return result;
}
\end{lstlisting}
\subsection{Union find}
\lstinputlisting{Autre/unionfind.java}
\subsection{Fenwick Tree (RSQ solver)}
\lstinputlisting{Autre/Fenwicktree.java}
