\section{Geometry}
Be careful of rounding errors. Define $E$ in function of the problem.
\lstinline|Double.parseDouble| est bien plus lent que \lstinline|Integer.parseInt|.
\begin{lstlisting}
boolean eq(double a,double b){return Math.abs(a - b) <= E;}
boolean le(double a,double b){return a < b - E;}
boolean leq(double a,double b){return a <= b + E;}
\end{lstlisting}
\subsection{Vectors}
\subsubsection{Rotation around (0,0)}
$(x, y) \leftrightarrow x + y i$\\
$\rho e^{i\theta} = \rho \cos(\theta) + i \rho \sin(\theta)$\\

$(x, y)$ rotated by $\alpha$ is
$(\cos(\alpha) x - \sin(\alpha) y, \sin(\alpha)  x + \cos(\alpha) y)$
\input{Geometrie/points.tex}

\subsection{Lines}
General equation:$Ax + By = C$. The line through $(x_1, y_1), (x_2, y_2)$ is given by: $A = y_2 - y_1$, $B = x_1 - x_2$, $C = A x_1 + B y_1$.
\subsubsection{Intersections}
Intersection exists there is a solution for $A_1 x + B_1 y = C_1$ and $A_2 x + B_2 y = C_2$. This happens if and only if $$d := \det \begin{pmatrix}
A_1 & B_1 \\
A_2 & B_2 \\
\end{pmatrix} \neq 0$$
Intersection is given by
$$\begin{pmatrix}
x\\
y
\end{pmatrix} = 
\begin{pmatrix}
A_1 & B_1 \\
A_2 & B_2 \\
\end{pmatrix}^{-1} 
\begin{pmatrix}
C_1 \\
C_2
\end{pmatrix}
=
\frac{1}{d}
\begin{pmatrix}
B_2 & -B_1 \\
-A_2 & A_1 \\
\end{pmatrix} 
\begin{pmatrix}
C_1 \\
C_2
\end{pmatrix}
$$
\subsubsection{Perpendicular line}
The lines perpendicular to $Ax + By = C$ are
$$-Bx + Ay = D \quad \text{for $D \in \mathbb{R}$}$$
If we want the one that goes through $(x_0, y_0)$ set
$$D = - B x_0 + A y_0$$
\subsubsection{Orthogonal Symmetry}
For a line, find $X'$, the point which is the orthogonal symmetry of $X$ on line $a$. \\
Computes the perpendicular of the given line that goes through $X$. Compute intersection $Y$. $X' = Y - (X - Y)$.
\subsection{Segments}
\subsubsection{Intersection}
\begin{itemize}
\item Treat segments as lines.
\item If $d \neq 0$, compute line intersection $(x, y)$.
\item Segments intersect iff
\begin{align*}
\min(x_1, x_2) \leq & \ x \leq \max(x_1, x_2) \\
\min(y_1, y_2) \leq & \ y \leq \max(y_1, y_2)
\end{align*}
\end{itemize}
\begin{lstlisting}
boolean intersects(Point p1, Point p2, Point p3, Point p4) {
  double o1 = orient(p1, p2, p3);
  double o2 = orient(p1, p2, p4);
  double o3 = orient(p3, p4, p1);
  double o4 = orient(p3, p4, p2);
  // check first condition of the lemma
  if(o1 * o2 < 0 && o3 * o4 < 0) return true;
  // check seconds condition of the lemma
  if(o1 == 0 && inBox(p1, p2, p3)) return true;
  if(o2 == 0 && inBox(p1, p2, p4)) return true;
  if(o3 == 0 && inBox(p3, p4, p1)) return true;
  if(o4 == 0 && inBox(p3, p4, p2)) return true;
  return false;
}
\end{lstlisting}
\subsubsection{Intersections problem}
Given a lot of segments, return true if it exists a pair that intersects.
\begin{lstlisting}
boolean segmentIntersection(Segment[] S) {
  Event[] events = new Event[2 * S.length];
  // create event points
  for(int i = 0, j = 0; i < S.length; i++) {
    events[j++] = new Event(S[i].l.x, true, S[i]);
    events[j++] = new Event(S[i].r.x, false, S[i]);
  }
  Arrays.sort(events);
  SegmentCmp cmp = new SegmentCmp();
  TreeSet<Segment> T = new TreeSet<Segment>(cmp);
  // sweep line
  for(Event event : events) {
    Segment s = event.s;
    cmp.x = event.x;
    if(event.isLeft) {
      // new segment found. check if it intersects one of its neighbors
      T.add(s);
      Segment above = T.higher(s);
      Segment bellow = T.lower(s);
      if((above != null && intersects(above, s)) || 
         (bellow != null && intersects(bellow, s)))
        return true;
    } else {
      // end of segment. check if its neighbors intersect
      Segment above = T.higher(s);
      Segment bellow = T.lower(s);
      if(above != null && bellow != null && intersects(above, bellow))
        return true;
      T.remove(s);
    }
  }
  return false;
}

class Event implements Comparable<Event> {
  double x;
  boolean isLeft;
  Segment s;
  public Event(double x, boolean isLeft, Segment s) {
    this.x = x;
    this.isLeft = isLeft;
    this.s = s;
  }
  public int compareTo(Event other) {
    int cmp = Double.compare(x, other.x);
    // ensure that left comes before right
    if(cmp == 0) return isLeft? -1 : 1;
    return cmp;
  }
  public String toString() {
    return x + " " + isLeft;
  }
}

class SegmentCmp implements Comparator<Segment> {
  double x;
  public int compare(Segment s1, Segment s2) {
    // compute A,B,C from eq Ax + by = C for each segment
    double A1 = s1.r.y - s1.l.y;
    double B1 = s1.l.x - s1.r.x;
    double C1 = A1 * s1.l.x + B1 * s1.l.y;

    double A2 = s2.r.y - s2.l.y;
    double B2 = s2.l.x - s2.r.x;
    double C2 = A2 * s2.l.x + B2 * s2.l.y;

    // no divisions =)
    double t1 = B2 * (C1 - A1 * x);
    double t2 = B1 * (C2 - A2 * x);
    if(t1 == t2) {
      return s1 == s2? 0 : -1;
    } else if(B1 * B2 > 0) {
      return Double.compare(t1, t2);
    } else {
      return Double.compare(t2, t1);
    }
  }
}
\end{lstlisting}
\subsection{Circles}
\subsubsection{Circles from 3 points}
\begin{itemize}
\item $3$ non collinear points define a unique circle.
\item $c = $ intersection of bisectors of $XY$ and $YZ$. 
\end{itemize}
\subsection{Polygon}
\subsubsection{Triangles}
\begin{itemize}
  \item côtés $a,b,c$, angles $A,B,C$, hauteurs $h_A,h_B,h_C$, $s=\frac{a+b+c}{2}$, aire $S$.
  \item Aire: $S=ah_A/2$, $S=ab\sin C/2$, $S=\sqrt{s(s-a)(s-b)(s-c)}$.
  \item Inradius $r=\frac{S}{s}$.
  \item Outradius $2R = \frac{a}{\sin A} = \frac{b}{\sin B} = \frac{c}{\sin C}$.
  \item $rR = \frac{abc}{4s}$.
\end{itemize}
\subsubsection{Check convexity}
\begin{lstlisting}
boolean isConvex(Point[] P) {
  if(P.length < 3) return false;
  double o1 = orient(P[P.length-1], P[0], P[1]);
  for (int i = 0; i < P.length; i++) {
    double o2 = orient(P[i], P[i + 1], P[i + 2]);
    if(o1 * o2  < 0) {
      return false;
    } else if (o2 != 0) {
      o1 = o2;
    }
  }
  return true;
}
\end{lstlisting}
\subsubsection{Winding number}
\begin{lstlisting}
// assumes p is not on P
double winding(Point[] P, Point p) {
  //make a translation so p = (0, 0)
  for(Point q : P) {
    q.x -= p.x;
    q.y -= p.y;
  }
  double w = 0;
  for(int i = 0; i < P.length - 1; i++) {
    if(P[i].y * P[i + 1].y < 0) {
      // segment crosses the x-axis
      double r = (P[i].y - P[i+1].y) * P[i].x + P[i].y * (P[i+1].x - P[i].x);
      //check for intersection with the positive x-axis
      if((P[i].y - P[i+1].y > 0 && r > 0) || (P[i].y - P[i+1].y < 0 && r < 0)) {
        // segment fully crosses the x-axis
        // - to + add 1, + to - subtract 1
        w += P[i].y < 0? 1 : -1;
      } else if(P[i].y == 0 && P[i].x > 0) {
        // the segment starts at the x-axis
        // 0 to + add 0.5, 0 to - subtract 0.5
        w += P[i+1].y > 0? 0.5 : -0.5;
      } else if(P[i+1].y == 0 && P[i+1].x > 0) {
        // the segment ends at the x-axis
        // - to 0 add 0.5, + to 0 subtract 0.5
        w += P[i].y < 0? 0.5 : -0.5;
      }
    }
  }
  return w;
}
\end{lstlisting}
\subsubsection{Convex Hull}
\begin{lstlisting}
Point[] convexHull(Point[] points) {
  // sort points by increasing x coordinates
  Arrays.sort(points, new xComp());
  // build upper chain
  Point[] upChain = buildChain(points, 1);
  // build lower chain
  Point[] loChain = buildChain(points, -1);
  Point[] hull = new Point[upChain.length + loChain.length - 2];
  int i;
  // build convex hull from upper and lower chain
  for(i = 0; i < upChain.length; i++) {
    hull[i] = upChain[i];
  }
  for(int j = loChain.length - 2; j >= 1; j--) {
    hull[i] = loChain[j];
  }
  return hull;
}

Point[] buildChain(Point[] points, int sgn) {
  Point[] S = new Point[points.length];
  int k = 0;
  S[k++] = points[0]; // push points[0]
  S[k++] = points[1]; // push points[1]
  // build chain
  for(int i = 2; i < points.length; i++) {
    //double orient = orient(S[k - 2], S[k - 1], points[i]);
    while(k >= 2 && sgn * orient(S[k - 2], S[k - 1], points[i]) >= 0) {
      S[k - 1] = null; // pop
      k--;
    }
    S[k++] = points[i]; // push points[i]
  }
  return Arrays.copyOf(S, k);
}
\end{lstlisting}

\subsection{Interval Tree}

\includegraphics[scale=0.38]{Geometrie/it.png}

\lstinputlisting{Geometrie/intervaltree.java}

\subsection{Area of union of rectangles}

\lstinputlisting{Geometrie/rectangles.java}

%\subsection{C library by Xiao}
%\lstset{language=C}
%{\setmainfont{CODE2000.TTF} % font that supports chinese
%\lstinputlisting{Geometrie/Geometry.h}
%}
%\lstset{language=Java}
