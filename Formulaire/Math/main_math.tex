\section{Math}
\subsection{Permutations, Combinaisons, Arrangements... {\footnotesize \textit{non-testé}}}
\begin{lstlisting}
void nextPerm(int[] p) {
  int n = p.length;
  int k = n - 2;
  while(k >= 0 && p[k] >= p[k + 1]) {k--;}
  int l = n - 1;
  while(p[k] >= p[l]) {l--;}
  swap(p, k, l);
  reverse(p, k + 1, n);
}

LinkedList<Integer> getIPermutation(int n, int index) {
  LeftRightArray lr = new LeftRightArray(n);
  lr.freeAll();
  LinkedList<Integer> perm = new 
  LinkedList<Integer>();
  getPermutation(lr, index, fact(n), perm);
  return perm;
}

void getPermutation(LeftRightArray lr, int i, long fact, LinkedList<Integer> perm) {
  int n = lr.size();
  if(n == 1) {
    perm.add(lr.freeIndex(0, false));
  } else {
    fact /= n;
    int j = (int)(i / fact);
    perm.add(lr.freeIndex(j, true));
    i -= j * fact;
    getPermutation(lr, i, fact, perm);
  }
}

int[] getICombinadic(int n, int k, long i) { 
  int[] comb = new int[k];
  int j = 0;
  for(int z = 1; z <= n; z++) {
    if ( k == 0 ) {
      break;
    }
    long threshold = C(n - z, k - 1);
    if (i < threshold) {
      comb[j] = z - 1;
      j++;
      k = k - 1;
    } else if (i >= threshold) {
      i = i - threshold;
    }
  }
  return comb;
}

void combinations(int n, int k) {
  combinations(n, 0, new int[k], 0);
}

void combinations(int n, int j, int[] comb, int k) {
  if(k == comb.length) {
    System.out.println(Arrays.toString(comb));
  } else {
    for(int i = j; i < n; i++) {
      comb[k] = i;
      combinations(n, i + 1, comb, k + 1);
    }
  }
}
void subsets(int[] set) {
  int n = (1 << set.length);
  for(int i = 0; i < n; i++) {
    int[] sub = new int[Integer.bitCount(i)];
    int k = 0, j = 0;
    while((1 << j) <= i) {
      if((i & (1 << j)) == (1 << j)) {
        sub[k++] = set[j];
      }
      j++;  
    }
    System.out.println(Arrays.toString(sub));
  }
}
\end{lstlisting}
\subsection{Décomposition en fractions unitaires {\footnotesize \textit{non-testé}}}
Ecrire $0<\frac{p}{q}<1$ sous forme de sommes de $\frac{1}{k}$
\begin{lstlisting}
void expandUnitFrac(long p, long q)
{
	if(p != 0)
	{
		long i = q % p == 0 ? q/p : q/p + 1;
		System.out.println("1/" + i);
		expandUnitFrac(p*i-q, q*i);
	}
}
\end{lstlisting}
\subsection{Combinaison}
Nombre de combinaison de taille $k$ parmi $n$ ($C^k_n$)

Cas spécial: $C^k_n\ mod\ 2 = n\oplus m$
\begin{lstlisting}
long C(int n, int k)
{
	double r = 1;
	k = Math.min(k, n - k);
	for(int i = 1; i <= k; i++)
		r /= i;
	for(int i = n; i >= n - k + 1; i--)
		r *= i;
	return Math.round(r);
}
\end{lstlisting}
%TODO: Nombres de Catalan
\subsection{Suite de fibonacci {\footnotesize \textit{non-testé}}}
$f(0) = 0$, $f(1) = 1$ et $f(n) = f(n - 1) + f(n - 2)$

Valeur réelle mais avec des flottant: $f(n)=\frac{1}{\sqrt{5}}((\frac{1+\sqrt{5}}{2})^n-(-\frac{2}{1+\sqrt{5}})^n)$

En fait, $f(n)$ est toujours l'entier le plus proche de $f_{approx}(n)=\frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2})^n$
\begin{lstlisting}
long fib(n)
{
	int i=1; int h=1; int j=0; int k=0; int t;
	while(n > 0)
	{
		if(n % 2 == 1)
		{
			t = j * h;
			j=i * h + j * k + t; 
			i=i * k + t;
    		}
   		t = h * h;
   		h = 2 * k * h + t;
   		k = k * k + t;
	}
	n = (int)n / 2; 
	return j;
}
\end{lstlisting}

\subsection{Number theory}
$\phi(N) = N \times \prod_{p | N} (1 - \frac{1}{p}) = \#\{k < N | \gcd(k,N) = 1\}$
\begin{lstlisting}
long phi(long n, int primes[]) {
  long ans = n;
  for (int i = 0; i < primes.length && primes[i] * primes[i] <= n; i++) {
    int p = primes[i];
    if (n % p == 0) ans -= ans / p;
    while (n % p == 0) ans /= p;
  }
  if (n != 1) ans -= ans / n;
  return ans;
}
\end{lstlisting}
