\section{Math}
\subsection{Permutations, Combinations, Arrangements... {\footnotesize \textit{untested}}}
\begin{lstlisting}
void nextPerm(int[] p) {
  int n = p.length;
  int k = n - 2;
  while(k >= 0 && p[k] >= p[k + 1]) {k--;}
  int l = n - 1;
  while(p[k] >= p[l]) {l--;}
  swap(p, k, l);
  reverse(p, k + 1, n);
}

LinkedList<Integer> getIPermutation(int n, int index) {
  LeftRightArray lr = new LeftRightArray(n);
  lr.freeAll();
  LinkedList<Integer> perm = new
  LinkedList<Integer>();
  getPermutation(lr, index, fact(n), perm);
  return perm;
}

void getPermutation(LeftRightArray lr, int i, long fact, LinkedList<Integer> perm) {
  int n = lr.size();
  if(n == 1) {
    perm.add(lr.freeIndex(0, false));
  } else {
    fact /= n;
    int j = (int)(i / fact);
    perm.add(lr.freeIndex(j, true));
    i -= j * fact;
    getPermutation(lr, i, fact, perm);
  }
}

int[] getICombinadic(int n, int k, long i) {
  int[] comb = new int[k];
  int j = 0;
  for(int z = 1; z <= n; z++) {
    if ( k == 0 ) {
      break;
    }
    long threshold = C(n - z, k - 1);
    if (i < threshold) {
      comb[j] = z - 1;
      j++;
      k = k - 1;
    } else if (i >= threshold) {
      i = i - threshold;
    }
  }
  return comb;
}

void combinations(int n, int k) {
  combinations(n, 0, new int[k], 0);
}

void combinations(int n, int j, int[] comb, int k) {
  if(k == comb.length) {
    System.out.println(Arrays.toString(comb));
  } else {
    for(int i = j; i < n; i++) {
      comb[k] = i;
      combinations(n, i + 1, comb, k + 1);
    }
  }
}
void subsets(int[] set) {
  int n = (1 << set.length);
  for(int i = 0; i < n; i++) {
    int[] sub = new int[Integer.bitCount(i)];
    int k = 0, j = 0;
    while((1 << j) <= i) {
      if((i & (1 << j)) == (1 << j)) {
        sub[k++] = set[j];
      }
      j++;
    }
    System.out.println(Arrays.toString(sub));
  }
}
\end{lstlisting}
\subsection{Decomposition in unit fractions {\footnotesize \textit{untested}}}
Write $0<\frac{p}{q}<1$ as a sum of $\frac{1}{k}$
\begin{lstlisting}
void expandUnitFrac(long p, long q)
{
	if(p != 0)
	{
		long i = q % p == 0 ? q/p : q/p + 1;
		System.out.println("1/" + i);
		expandUnitFrac(p*i-q, q*i);
	}
}
\end{lstlisting}
\subsection{Combination}
Number of combinations of $k$ elements within $n$ ones ($C^k_n$)

Special case : $C^k_n\ mod\ 2 = n\oplus m$
\begin{lstlisting}
long C(int n, int k) {
  double r = 1;
  k = Math.min(k, n - k);
  for(int i = 1; i <= k; i++)
  r /= i;
  for(int i = n; i >= n - k + 1; i--)
  r *= i;
  return Math.round(r);
}
\end{lstlisting}
\subsubsection{Catalan numbers}
$\cat(n) = \frac{C_n^{2n}}{n+1}$ $\cat(n+1) = \frac{(2n+2)(2n+1)}{(n+2)(n+1)}\cat(n)$
\begin{itemize}
  \item distinct binary trees with $n$ vertices.
  \item expressions containing $n$ pairs of parentheses correctly matched (e.g. $n=3$ $()()(),()(()),(())(),((())),(()())$).
  \item parenthesize $n+1$ factors (e.g. $n=3$ $(ab)(cd),a(b(cd)),((ab)c)(d),(a(bc))(d),a((bc)d)$).
  \item triangulate a convex polygon of $n+2$ sides.
  \item number of monotonic paths along the edge of a $n\times n$ grid which do not pass above de diagonal.
\end{itemize}
\subsection{Fibonacci series {\footnotesize \textit{untested}}}
$f(0) = 0$, $f(1) = 1$ et $f(n) = f(n - 1) + f(n - 2)$.\\
The following relation enables us to compute every number of the series in $O(log(n))$ :\\
$$\begin{pmatrix}
1 & 1\\
1 & 0
\end{pmatrix}^n=\begin{pmatrix}
f_{n+1} & f_n\\
f_n & f_{n-1}
\end{pmatrix}$$
\begin{lstlisting}
long fib(n) {
  int i=1; int h=1; int j=0; int k=0; int t;
  while(n > 0) {
    if(n % 2 == 1) {
      t = j * h;
      j=i * h + j * k + t;
      i=i * k + t;
    }
    t = h * h;
    h = 2 * k * h + t;
    k = k * k + t;
  }
  n = (int)n / 2;
  return j;
}
\end{lstlisting}
\subsection{Cycle finding}
\begin{lstlisting}
int[] floydCycleFinding (int x0) {
  int tortoise = f(x0), hare = f(f(x0));
  while (tortoise != hare) {
    tortoise = f(tortoise);
    hare = f(f(hare)); }
  int mu = 0; hare = x0; // first
  while (tortoise != hare) {
    tortoise = f(tortoise); hare = f(hare); mu++; }
  int lambda = 1; hare = f(tortoise); // length
  while (tortoise != hare) {
    hare = f(hare); lambda++; }
  return new int[] {mu, lambda};
}
\end{lstlisting}
\subsection{Number theory}
\subsubsection{Misc}
\begin{lstlisting}
long gcd (long a, long b) {
  return (b == 0) ? a : gcd(b, a % b);
}
long lcm (long a, long b) {
  return a * (b / gcd(a,b));
}
long modInverse (long a, long b) {
  return big(a).modInverse(big(b)).longValue();
}
\end{lstlisting}
\subsubsection{Euler phi}
$\phi(N) = N \times \prod_{p | N} (1 - \frac{1}{p}) = \#\{k < N | \gcd(k,N) = 1\}$
\begin{lstlisting}
long phi(long n, int primes[]) {
  long ans = n; // Method 1
  for (int i = 0; i < primes.length && primes[i] * primes[i] <= n; i++) {
    int p = primes[i];
    if (n % p == 0) ans -= ans / p;
    while (n % p == 0) ans /= p;
  }
  if (n != 1) ans -= ans / n;
  return ans;
}
\end{lstlisting}
\begin{lstlisting}
for (int i = 1; i <= 1000000; i++) phi[i] = i;
for (int i = 2; i <= 1000000; i++) // Method 2
  if (phi[i] == i) // i is prime
    for (int j = i; j <= 1000000; j += i)
      phi[j] = (phi[j] / i) * (i - 1);
\end{lstlisting}
\subsubsection{Équations diophantiennes}
$ax + by = c$. $d = \gcd(a,b)$, no sol si $d$ divise pas $c$ sinon $(a,b) = (x (n/d) + (b/d)n, y (n/d) + (a/d)n)$ où $ax + by = d$ $n \in \mathbb{Z}$.
\begin{lstlisting}
static int x, y;
static int extendedEuclid(int a, int b) {
  if (b == 0) { x = 1; y = 0; return a; }
  int d = extendedEuclid(b, a % b);
  int x1 = y;
  int y1 = x - (a / b) * y;
  x = x1;
  y = y1;
  return d;
}
\end{lstlisting}
\subsubsection{Chinese remainder theorem}
\begin{lstlisting}
static long[] chinese (long[] b, long[] m) {
  long x = b[0], l = m[0];
  for (int i = 1; i < m.length; i++) {
    long m1 = m[i], b1 = b[i];
    long d = gcd(l, m1);
    if ((x - b1) % d != 0) return null;
    long lcm = l * (m1 / d);
    long t1 = ((((x - b1) / d) % lcm) * (modInverse(m1/d, l/d) % lcm)) % lcm;
    x = (b1 + ((t1 * m1) % lcm)) % lcm;
    l = lcm;
  }
  return new long[] {x, l};
}
\end{lstlisting}
